<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Untitled Cube Game</title>
<style>
  /* ... keep previous styles for UI, canvas, joystick, etc. (same as before) ... */
  body, html {
    margin: 0; padding: 0; overflow: hidden; background: #121212; color: #eee;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
  }
  #gameCanvas {
    display: block;
    background: linear-gradient(135deg, #1f1f1f, #2a2a2a);
    margin: 0 auto;
    touch-action: none;
    box-shadow: 0 0 20px #0af;
    border-radius: 10px;
  }
  #ui {
    position: absolute;
    top: 15px; left: 15px;
    font-size: 20px;
    background: rgba(20, 20, 30, 0.85);
    padding: 8px 14px;
    border-radius: 12px;
    box-shadow: 0 0 12px #08f7ffaa;
    user-select: none;
    display: flex;
    gap: 18px;
    font-weight: 600;
    letter-spacing: 0.05em;
    z-index: 10;
  }
  #ui span {
    user-select: text;
  }
  #deathOverlay.hit {
    position: fixed;
    top: 0; left: 0; width: 100vw; height: 100vh;
    background: rgba(255, 0, 0, 0.6);
    pointer-events: none;
    animation: flash 0.08s ease-out;
    z-index: 25;
  }
  @keyframes flash {
    from { opacity: 1; }
    to { opacity: 0; }
  }

  /* menus and buttons styles same as before */
  /* ... omitted for brevity but use same from last code ... */
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="ui" style="display:none;">
  <span>‚ù§Ô∏è health: <span id="health">0</span></span>
  <span>‚≠ê score: <span id="score">0</span></span>
  <span>ü™ô coins: <span id="coins">0</span></span>
  <span>üéö difficulty: <span id="difficultyText"></span></span>
</div>

<div id="deathOverlay"></div>

<div id="mainMenu">
  <h1>Untitled Cube Game</h1>
  <div id="diffButtons">
    <button data-difficulty="easy">Easy</button>
    <button data-difficulty="medium">Medium</button>
    <button data-difficulty="hard">Hard</button>
  </div>
  <button id="playBtn" disabled>Play</button>
  <button id="openStoreBtn">Store</button>
</div>

<div id="deathMenu" style="display:none; flex-direction: column; align-items: center; justify-content: center;">
  <h2>Game Over</h2>
  <div id="finalScore" style="margin: 10px 0; font-weight: 700; font-size: 22px;">score: 0</div>
  <div id="finalCoins" style="margin: 10px 0; font-weight: 700; font-size: 22px;">coins earned: 0</div>
  <button id="restartBtn">Restart</button>
  <button id="mainMenuBtn">Main Menu</button>
</div>

<div id="storeScreen" style="display:none;">
  <h2>Store</h2>
  <div id="coinsDisplay">coins: 0</div>
  <div id="itemsList"></div>
  <button id="closeStore">Back</button>
</div>

<div id="joystickContainer" style="display:none;">
  <div id="joystickThumb"></div>
</div>

<button id="pauseBtn" style="display:none;">pause</button>

<script>
(() => {
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  let W, H;
  function resize() {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W;
    canvas.height = H;
  }
  window.addEventListener("resize", resize);
  resize();

  // DOM elements (same as previous code)
  const ui = document.getElementById("ui");
  const healthSpan = document.getElementById("health");
  const scoreSpan = document.getElementById("score");
  const coinsSpan = document.getElementById("coins");
  const difficultyText = document.getElementById("difficultyText");

  const deathOverlay = document.getElementById("deathOverlay");
  const mainMenu = document.getElementById("mainMenu");
  const deathMenu = document.getElementById("deathMenu");
  const finalScore = document.getElementById("finalScore");
  const finalCoins = document.getElementById("finalCoins");

  const playBtn = document.getElementById("playBtn");
  const restartBtn = document.getElementById("restartBtn");
  const mainMenuBtn = document.getElementById("mainMenuBtn");

  const storeScreen = document.getElementById("storeScreen");
  const openStoreBtn = document.getElementById("openStoreBtn");
  const closeStore = document.getElementById("closeStore");
  const coinsDisplay = document.getElementById("coinsDisplay");
  const itemsList = document.getElementById("itemsList");

  const pauseBtn = document.getElementById("pauseBtn");

  const joystickContainer = document.getElementById("joystickContainer");
  const joystickThumb = document.getElementById("joystickThumb");

  // keys
  const keys = {};

  // localStorage keys
  const KEY_COINS = "ucg_coins";
  const KEY_OWNED = "ucg_ownedSkins";
  const KEY_SELECTED = "ucg_selectedSkin";
  const KEY_POWERUPS = "ucg_powerups";
  const KEY_DIFF = "ucg_difficulty";

  // game state
  let coins = 0;
  let difficulty = "easy";

  // player
  const player = {
    x: 0,
    y: 0,
    size: 30,
    speed: 5,
    health: 50,
    maxHealth: 50,
  };

  let enemies = [];
  let particles = [];
  let fragments = [];
  const MAX_PARTICLES = 70;

  let running = false;
  let paused = false;

  let lastTime = 0;
  let lastScoreTick = 0;

  // skins and powerups (same as before, omitted for brevity)
  // ...

  // difficulty settings ‚Äî increased difficulty, especially hard mode
  const difficulties = {
    easy: { spawn: 2500, enemySpeed: 1.5, scorePerSec: 1, healthMult: 1, coinMult: 1 },
    medium: { spawn: 1500, enemySpeed: 3, scorePerSec: 3, healthMult: 0.85, coinMult: 1.5 },
    hard: { spawn: 400, enemySpeed: 8, scorePerSec: 10, healthMult: 0.3, coinMult: 3 },
  };

  // joystick state (same as before)
  // ...

  const MAX_HITS = 5;
  let hitsTaken = 0;

  function clamp(val, min, max) {
    return val < min ? min : val > max ? max : val;
  }
  function rectsCollide(r1, r2) {
    return (
      r1.x < r2.x + r2.size &&
      r1.x + r1.size > r2.x &&
      r1.y < r2.y + r2.size &&
      r1.y + r1.size > r2.y
    );
  }
  function saveGame() {
    localStorage.setItem(KEY_COINS, coins);
    localStorage.setItem(KEY_OWNED, JSON.stringify(ownedSkins));
    localStorage.setItem(KEY_SELECTED, selectedSkin);
    localStorage.setItem(KEY_POWERUPS, JSON.stringify(ownedPowerups));
    localStorage.setItem(KEY_DIFF, difficulty);
  }
  function loadGame() {
    coins = Number(localStorage.getItem(KEY_COINS)) || 0;
    ownedSkins = JSON.parse(localStorage.getItem(KEY_OWNED)) || ["green"];
    selectedSkin = localStorage.getItem(KEY_SELECTED) || "green";
    ownedPowerups = JSON.parse(localStorage.getItem(KEY_POWERUPS)) || [];
    difficulty = localStorage.getItem(KEY_DIFF) || "easy";
  }
  function pickSkinColor(id) {
    let s = skins.find((sk) => sk.id === id);
    return s ? s.color : "#0f0";
  }
  function hasPowerup(id) {
    return ownedPowerups.includes(id);
  }

  function maxPlayerHealth() {
    let base = 50;
    if (hasPowerup("hpUp")) base += 20;
    return base;
  }
  function coinMultiplier() {
    return hasPowerup("coinBoost") ? 2 : 1;
  }

  // SPAWN ENEMY from random side, heading toward player center
  function spawnEnemy() {
    const side = Math.floor(Math.random() * 4); // 0 top,1 right,2 bottom,3 left
    const size = 20 + Math.random() * 15;
    let x, y, vx, vy;

    // player center coords
    const px = player.x + player.size / 2;
    const py = player.y + player.size / 2;

    if (side === 0) {
      // top
      x = Math.random() * (W - size);
      y = -size - 10;
    } else if (side === 1) {
      // right
      x = W + size + 10;
      y = Math.random() * (H - size);
    } else if (side === 2) {
      // bottom
      x = Math.random() * (W - size);
      y = H + size + 10;
    } else {
      // left
      x = -size - 10;
      y = Math.random() * (H - size);
    }

    // calculate velocity vector toward player center
    const angle = Math.atan2(py - y, px - x);
    const speed = difficulties[difficulty].enemySpeed;
    vx = Math.cos(angle) * speed;
    vy = Math.sin(angle) * speed;

    enemies.push({ x, y, size, vx, vy, color: "#f00" });
  }

  // spawn particles (same as before)
  function spawnParticle() {
    if (particles.length >= MAX_PARTICLES) return;
    particles.push({
      x: Math.random() * W,
      y: Math.random() * H,
      size: 3 + Math.random() * 3,
      speedX: -0.25 - Math.random() * 0.25,
      alpha: 0.5,
    });
  }

  // fragments and other functions same as before, omitted for brevity

  function createFragments() {
    fragments = [];
    const fragCount = 14;
    for (let i = 0; i < fragCount; i++) {
      fragments.push({
        x: player.x + player.size / 2,
        y: player.y + player.size / 2,
        size: 6 + Math.random() * 4,
        vx: (Math.random() - 0.5) * 6,
        vy: (Math.random() - 0.5) * 6,
        life: 60 + Math.random() * 20,
        alpha: 1,
        color: pickSkinColor(selectedSkin),
      });
    }
  }
  function drawFragments() {
    for (let f of fragments) {
      const r = parseInt(f.color.slice(1, 3), 16);
      const g = parseInt(f.color.slice(3, 5), 16);
      const b = parseInt(f.color.slice(5, 7), 16);
      ctx.fillStyle = `rgba(${r},${g},${b},${f.alpha.toFixed(2)})`;
      ctx.fillRect(f.x, f.y, f.size, f.size);
    }
  }
  function updateFragments() {
    for (let f of fragments) {
      f.x += f.vx;
      f.y += f.vy;
      f.vx *= 0.92;
      f.vy += 0.25;
      f.life--;
      f.alpha = f.life / 80;
    }
    fragments = fragments.filter((f) => f.life > 0);
  }

  // joystick init etc (same as before)
  // ...

  window.addEventListener("keydown", (e) => {
    keys[e.key.toLowerCase()] = true;
  });
  window.addEventListener("keyup", (e) => {
    keys[e.key.toLowerCase()] = false;
  });

  let spawnTimer = 0;

  function gameLoop(time = 0) {
    if (!running || paused) {
      lastTime = time;
      requestAnimationFrame(gameLoop);
      return;
    }

    const delta = (time - lastTime) / 1000;
    lastTime = time;

    ctx.clearRect(0, 0, W, H);

    spawnTimer += delta * 1000;
    if (spawnTimer > difficulties[difficulty].spawn) {
      spawnEnemy();
      spawnTimer = 0;
    }

    if (particles.length < MAX_PARTICLES) {
      spawnParticle();
    }

    for (let p of particles) {
      p.x += p.speedX;
      if (p.x < -10) p.x = W + 10;
      ctx.fillStyle = `rgba(255,255,255,${p.alpha})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
      ctx.fill();
    }

    // move player
    let moveX = 0, moveY = 0;
    if (joystickPos.x !== 0 || joystickPos.y !== 0) {
      moveX = joystickPos.x * player.speed;
      moveY = joystickPos.y * player.speed;
    } else {
      if (keys["a"] || keys["arrowleft"]) moveX -= player.speed;
      if (keys["d"] || keys["arrowright"]) moveX += player.speed;
      if (keys["w"] || keys["arrowup"]) moveY -= player.speed;
      if (keys["s"] || keys["arrowdown"]) moveY += player.speed;
    }

    player.x += moveX;
    player.y += moveY;
    player.x = clamp(player.x, 0, W - player.size);
    player.y = clamp(player.y, 0, H - player.size);

    // draw player
    ctx.fillStyle = pickSkinColor(selectedSkin);
    ctx.fillRect(player.x, player.y, player.size, player.size);

    // update enemies and check collisions
    for (let i = enemies.length - 1; i >= 0; i--) {
      let e = enemies[i];
      e.x += e.vx;
      e.y += e.vy;
      ctx.fillStyle = e.color;
      ctx.fillRect(e.x, e.y, e.size, e.size);

      if (rectsCollide(player, e)) {
        enemies.splice(i, 1);
        hitsTaken++;
        showHitEffect();
        if (hitsTaken >= MAX_HITS) {
          running = false;
          createFragments();
          deathOverlay.classList.add("hit");
          setTimeout(() => {
            deathOverlay.classList.remove("hit");
            showDeathMenu();
          }, 300);
        }
      } else if (e.x < -50 || e.x > W + 50 || e.y < -50 || e.y > H + 50) {
        enemies.splice(i, 1);
      }
    }

    if (fragments.length > 0) {
      updateFragments();
      drawFragments();
    }

    if (time - lastScoreTick > 1000) {
      score += difficulties[difficulty].scorePerSec;
      lastScoreTick = time;
      const coinsEarned = Math.floor(score / 10) - Math.floor((score - difficulties[difficulty].scorePerSec) / 10);
      coins += coinsEarned * coinMultiplier() * difficulties[difficulty].coinMult;
    }

    healthSpan.textContent = Math.max(0, player.maxHealth * difficulties[difficulty].healthMult - (hitsTaken * (player.maxHealth * difficulties[difficulty].healthMult / MAX_HITS))).toFixed(0);
    scoreSpan.textContent = score.toFixed(0);
    coinsSpan.textContent = coins.toFixed(0);
    difficultyText.textContent = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);

    requestAnimationFrame(gameLoop);
  }

  function showHitEffect() {
    deathOverlay.classList.add("hit");
    setTimeout(() => {
      deathOverlay.classList.remove("hit");
    }, 80);
  }

  function showDeathMenu() {
    ui.style.display = "none";
    deathMenu.style.display = "flex";
    finalScore.textContent = `score: ${score.toFixed(0)}`;
    const earnedCoins = Math.floor(score / 10) * coinMultiplier() * difficulties[difficulty].coinMult;
    finalCoins.textContent = `coins earned: ${earnedCoins.toFixed(0)}`;
    coins += earnedCoins;
    saveGame();
  }

  function resetGame() {
    hitsTaken = 0;
    score = 0;
    enemies = [];
    particles = [];
    fragments = [];
    player.maxHealth = maxPlayerHealth();
    player.health = player.maxHealth;
    spawnTimer = 0;
    lastScoreTick = 0;
    running = true;
    paused = false;
    ui.style.display = "flex";
    pauseBtn.style.display = "block";
  }

  // difficulty buttons, play, restart, main menu, pause, store logic (same as previous, omitted for brevity)

  // start state
  ui.style.display = "none";
  pauseBtn.style.display = "none";
  loadGame();
  updateDiffButtons();
  playBtn.disabled = false;
  difficultyText.textContent = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);

  player.x = W / 2 - player.size / 2;
  player.y = H / 2 - player.size / 2;

  if (isMobile()) {
    initJoystick();
  } else {
    joystickContainer.style.display = "none";
  }
})();
</script>

</body>
</html>
